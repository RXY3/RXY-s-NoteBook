# ADS å¤ä¹ 

## chapter 1 AVLæ ‘ & Splayæ ‘

### AVLæ ‘
äº§ç”ŸèƒŒæ™¯ï¼š
- äºŒå‰æœç´¢æ ‘çš„ç¼ºç‚¹ï¼šå½“æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå¯èƒ½å¯¼è‡´æ ‘çš„ä¸å¹³è¡¡ï¼Œä½¿å¾—æŸ¥æ‰¾æ•ˆçŽ‡é™ä½Žã€‚

**å®šä¹‰**
æ ‘é«˜ï¼šæ ‘ä¸­èŠ‚ç‚¹çš„æœ€å¤§å±‚æ•°ç§°ä¸ºæ ‘çš„é«˜åº¦ã€‚ç©ºæ ‘çš„é«˜åº¦ä¸º-1ï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ ‘çš„é«˜åº¦ä¸º0ã€‚
AVLæ ‘ï¼šå¯¹äºŽä»»æ„èŠ‚ç‚¹ï¼Œå…¶å·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1çš„äºŒå‰æœç´¢æ ‘ã€‚ç§°ä¹‹ä¸ºä¸€ç§å¹³è¡¡äºŒå‰æ ‘ã€‚

ç”±æ­¤å¯å¾—ï¼ŒAVLæ ‘çš„é«˜åº¦ä¸ºO(logn)ã€‚

#### é’ˆå¯¹äºŽAVLæ ‘çš„æ“ä½œï¼š
æ‰¾åˆ°æœ€è¿‘çš„trouble finderèŠ‚ç‚¹ï¼Œå¯¹å…¶è¿›è¡Œæ—‹è½¬æ“ä½œã€‚
RR/LLï¼šå•æ—‹è½¬
RL/LRï¼šåŒæ—‹è½¬ï¼ˆå³ä»Žä¸­é—´æå–å‡ºæ¥

### Splayæ ‘
äº§ç”ŸèƒŒæ™¯ï¼š
- AVLæ ‘çš„ç¼ºç‚¹ï¼šåœ¨æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå¯èƒ½éœ€è¦å¤šæ¬¡æ—‹è½¬æ“ä½œï¼Œä½¿å¾—æ“ä½œæ•ˆçŽ‡é™ä½Žã€‚
- äºŒå‰æœç´¢æ ‘çš„ç¼ºç‚¹ï¼šåœ¨æŸ¥æ‰¾èŠ‚ç‚¹æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ ‘çš„æ·±åº¦å¢žåŠ ï¼Œä½¿å¾—æŸ¥æ‰¾æ•ˆçŽ‡é™ä½Žã€‚
- ä¸ºäº†è§£å†³ä»¥ä¸Šé—®é¢˜ï¼Œå¼•å…¥äº†Splayæ ‘ã€‚

**å®šä¹‰**
Splayæ ‘ï¼šä¸€ç§è‡ªè°ƒæ•´çš„äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡æ—‹è½¬æ“ä½œå°†æŸ¥æ‰¾çš„èŠ‚ç‚¹è°ƒæ•´åˆ°æ ¹èŠ‚ç‚¹ï¼Œä»¥æé«˜æŸ¥æ‰¾æ•ˆçŽ‡ã€‚
å…¶å®žçŽ°ç›®æ ‡ä¸ºï¼š
åœ¨æ‘Šè¿˜(Amortized)å¤æ‚åº¦ð‘‚(logð‘)O(logN)çš„æƒ…å†µä¸‹å®Œæˆå¤§éƒ¨åˆ†å¯¹ç‚¹æ“ä½œã€‚

#### é’ˆå¯¹äºŽSplayæ ‘çš„æ“ä½œï¼š
- ä¼¸å±•æ“ä½œï¼šé€šè¿‡æ—‹è½¬æ“ä½œå°†æŸ¥æ‰¾çš„èŠ‚ç‚¹è°ƒæ•´åˆ°æ ¹èŠ‚ç‚¹ã€‚
- æ—‹è½¬æ“ä½œï¼šé€šè¿‡å·¦æ—‹æˆ–å³æ—‹æ“ä½œï¼Œå°†èŠ‚ç‚¹è°ƒæ•´åˆ°æ ¹èŠ‚ç‚¹ã€‚
  
é’ˆå¯¹äºŽæ¯ä¸€æ¬¡è®¿é—®ï¼Œéƒ½ä¼šè¿›è¡Œä¸€æ¬¡ä¼¸å±•æ“ä½œï¼Œä½¿å¾—è®¿é—®çš„èŠ‚ç‚¹æˆä¸ºæ ¹èŠ‚ç‚¹ã€‚
åˆ†ä¸ºzigzagå’Œzigzigä¸¤ç§æƒ…å†µã€‚
1. zigzagï¼šå…ˆå·¦æ—‹å†å³æ—‹
2. zigzigï¼šå…ˆå³æ—‹å†å³æ—‹ï¼ˆæ³¨æ„ï¼Œå…ˆæ—‹è½¬è¾ƒè¿œçš„ä¸€æ®µ

åŸºäºŽæ‘Šè¿˜åˆ†æžï¼ŒSplayæ ‘çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(logn)ã€‚
ä½¿ç”¨å…¶ä¸­çš„åŠ¿èƒ½å‘è¿›è¡Œåˆ†æžï¼š


### æ—¶é—´å¤æ‚åº¦åˆ†æžï¼š
è¡¨æ ¼å¦‚ä¸‹ï¼š

| æ“ä½œ | AVLæ ‘ | Splayæ ‘ |
| --- | --- | --- |
| æŸ¥æ‰¾ | O(logn) | O(logn) |
| æ’å…¥ | O(logn) | O(logn) |
| åˆ é™¤ | O(logn) | O(logn) |



## çº¢é»‘æ ‘å’ŒB+æ ‘

### çº¢é»‘æ ‘
å®šä¹‰ï¼š
- çº¢é»‘æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œå®ƒåœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šå¢žåŠ äº†ä¸€ä¸ªå­˜å‚¨ä½æ¥è¡¨ç¤ºèŠ‚ç‚¹çš„é¢œè‰²ï¼Œå¯ä»¥æ˜¯çº¢è‰²æˆ–é»‘è‰²ã€‚
Every node is either red or black.
The root is black.
Every leaf (NIL) is black.
if a node is red, then both its children are black.
For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.

black heightï¼šä»ŽæŸä¸ªèŠ‚ç‚¹åˆ°å…¶åŽä»£å¶å­èŠ‚ç‚¹çš„é»‘è‰²èŠ‚ç‚¹æ•°ç›®ã€‚

å«æœ‰Nä¸ªå†…éƒ¨èŠ‚ç‚¹çš„çº¢é»‘æ ‘çš„é«˜åº¦è‡³å¤šä¸º2log(N+1)ã€‚

#### çº¢é»‘æ ‘çš„æ—‹è½¬æ“ä½œ
1. æ’å…¥
- æ’å…¥èŠ‚ç‚¹ä¸ºçº¢è‰²
é’ˆå¯¹äºŽäºŽè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦åˆ†æˆä¸‰ç§æƒ…å†µè®¨è®ºï¼š

B. çˆ¶èŠ‚ç‚¹ä¸ºçº¢è‰²ï¼Œå”å”èŠ‚ç‚¹ä¸ºçº¢è‰²
C. çˆ¶èŠ‚ç‚¹ä¸ºçº¢è‰²ï¼Œå”å”èŠ‚ç‚¹ä¸ºé»‘è‰²







## Note for final

rbtree: 
é»‘é«˜çš„å®šä¹‰ï¼šä»ŽæŸä¸ªèŠ‚ç‚¹åˆ°å…¶åŽä»£å¶å­èŠ‚ç‚¹çš„é»‘è‰²èŠ‚ç‚¹æ•°ç›®ã€‚
nplï¼šnull path lengthï¼Œä»Žä¸€ä¸ªèŠ‚ç‚¹åˆ°ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„é»‘è‰²èŠ‚ç‚¹æ•°ç›®ã€‚
nplå’Œé»‘é«˜çš„å…³ç³»ï¼šnpl(x) = é»‘é«˜(x) + 1


skip list
- ä¸€ç§éšæœºåŒ–çš„æ•°æ®ç»“æž„
- é€šè¿‡å¤šå±‚é“¾è¡¨å®žçŽ°
- é€šè¿‡éšæœºåŒ–çš„æ–¹å¼å®žçŽ°å¹³è¡¡
å¤æ‚åº¦ï¼šO(logn)
æœ€å·®æƒ…å†µï¼šO(n)


Managing shared memory for parallel programs is simpler than normal sequential programs
è¿™ä¸ªåˆ¤æ–­æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºå¹¶è¡Œç¨‹åºä¸­ï¼Œéœ€è¦è€ƒè™‘åˆ°å¤šä¸ªçº¿ç¨‹ä¹‹é—´çš„æ•°æ®å…±äº«é—®é¢˜ï¼Œéœ€è¦è€ƒè™‘åˆ°çº¿ç¨‹ä¹‹é—´çš„åŒæ­¥é—®é¢˜ï¼Œå› æ­¤å¹¶è¡Œç¨‹åºçš„ç®¡ç†æ›´åŠ å¤æ‚ã€‚  # 2021-06-22 21:00:00

A binary tree that is not full cannot correspond to an optimal prefix code.
æ­£ç¡®ã€‚å› ä¸ºå¦‚æžœä¸æ˜¯æ»¡äºŒå‰æ ‘ï¼Œé‚£ä¹ˆå°±ä¼šæœ‰ç©ºçš„ä½ç½®ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´ç¼–ç çš„é•¿åº¦ä¸æ˜¯æœ€çŸ­çš„ã€‚  # 2021-06-22 21:00:00

TODO 
çº¢é»‘æ ‘åˆ é™¤



The function BinQueue_Merge is to merge two binomial queues H1 and H2, and return H1 as the resulting queue.

BinQueue BinQueue_Merge( BinQueue H1, BinQueue H2 ) { 
    BinTree T1, T2, Carry = NULL;     
    int i, j;
    H1->CurrentSize += H2-> CurrentSize;
    for ( i=0, j=1; j<= H1->CurrentSize; i++, j*=2 ) {
        T1 = H1->TheTrees[i]; T2 = H2->TheTrees[i];
        switch( 
            4*ï¼ˆcarryï¼Ÿ1ï¼š0ï¼‰ + 
(3åˆ†) ) { 
        case 0:
        case 4: break;
        case 3: 
        case 7: 
        
    H1->TheTrees[i]
(3åˆ†);
                H2->TheTrees[i] = NULL; break;
        case 1: 
                H1->TheTrees[i] = Carry; Carry = NULL; break;  
        case 2: 
                H1->TheTrees[i] = T2; H2->TheTrees[i] = NULL; break;
        case 5: 
                Carry = CombineTrees( T1, Carry );
                H1->TheTrees[i] = NULL; break;
        case 6: 
                Carry = CombineTrees( T1, T2 );
                H1->TheTrees[i] = H2->TheTrees[i] = NULL; break;
        } /* end switch */
    } /* end for-loop */
    return H1;
}




static int order = DEFAULT_ORDER;
typedef struct BpTreeNode BpTreeNode;
struct BpTreeNode {
    BpTreeNode** childrens;  /* Pointers to childrens. This field is not used by leaf nodes. */
    ElementType* keys;
    BpTreeNode* parent;
    bool isLeaf;  /* 1 if this node is a leaf, or 0 if not */
    int numKeys;  /* This field is used to keep track of the number of valid keys. 
    In an internal node, the number of valid pointers is always numKeys + 1. */
};


bool FindKey(BpTreeNode * const root, ElementType key){
    if (root == NULL) {
            return false;
    }
    int i = 0;
    BpTreeNode * node = root;
    while (node->isLeaf == 0
(3åˆ†)) {
        i = 0;
        while (i < node->numKeys) {
            if (node->keys[i] < key
(3åˆ†)) i++;
            else break;
        }
        node = node->childrens[i];
    }
    for(i = 0; i < node->numKeys; i++){
        if(node->keys[i] == key)
            return true;
    }
    return false;
}